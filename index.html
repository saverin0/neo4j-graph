<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Graph Explorer</title>
  <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>

  <style>
    html, body { width:100%; height:100%; margin:0; font-family: Arial, sans-serif; background:#070A12; }
    #app { display:flex; width:100%; height:100%; }
    #cy {
      flex: 1; height: 100%; position: relative;
      background: radial-gradient(circle at 30% 20%, #0b1230 0%, #070A12 45%, #050711 100%);
      overflow: hidden;
    }
    #cy::before{
      content:""; position:absolute; inset:0; pointer-events:none; z-index:0;
      background:
        radial-gradient(circle at 15% 25%, rgba(0,229,255,.10) 0%, transparent 52%),
        radial-gradient(circle at 85% 30%, rgba(255,43,214,.09) 0%, transparent 52%),
        radial-gradient(circle at 60% 85%, rgba(155,255,58,.08) 0%, transparent 55%),
        radial-gradient(circle at 30% 80%, rgba(255,211,74,.06) 0%, transparent 58%),
        radial-gradient(circle at 80% 75%, rgba(255,122,0,.06) 0%, transparent 58%);
      filter: blur(2px);
      animation: drift 12s ease-in-out infinite alternate;
    }
    #cy > canvas { position:relative; z-index:1; }
    @keyframes drift { from { transform: translate3d(-5px,-3px,0) scale(1.01); } to { transform: translate3d(6px,5px,0) scale(1.03); } }

    #side {
      width: 380px; border-left: 1px solid rgba(255,255,255,0.08);
      padding: 12px; box-sizing: border-box; overflow: auto;
      background: linear-gradient(180deg, rgba(15,18,34,0.98), rgba(8,10,18,0.98));
      color: #E9ECFF;
    }
    #toolbar {
      position: fixed; top: 12px; left: 12px; z-index: 999;
      background: rgba(10,12,22,0.85);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.45);
      padding: 10px 12px;
      display: flex; gap: 8px; align-items: center;
      backdrop-filter: blur(8px);
      color: #E9ECFF;
      max-width: 1100px;
      flex-wrap: wrap;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: #E9ECFF;
      padding: 7px 10px;
      border-radius: 10px;
      cursor: pointer;
      user-select: none;
    }
    .btn:hover { background: rgba(255,255,255,0.12); }
    #search {
      width: 280px; padding: 8px 10px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: #E9ECFF; outline: none;
    }
    #search::placeholder { color: rgba(233,236,255,0.6); }
    h3 { margin: 8px 0 10px; }
    .muted { color: rgba(233,236,255,0.65); font-size: 12px; line-height: 1.4; }
    .kv { margin: 10px 0; }
    .k { font-size: 12px; color: rgba(233,236,255,0.65); }
    .v { font-size: 13px; word-break: break-word; color: #E9ECFF; }
    code { background: rgba(255,255,255,0.08); padding: 1px 6px; border-radius: 6px; }
    hr { border: 0; border-top: 1px solid rgba(255,255,255,0.10); margin: 10px 0; }
    a { color: #9fd3ff; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.12); font-size:12px; }
  </style>
</head>

<body>
  <div id="toolbar">
    <div style="font-weight:700;">⚡ Graph Explorer</div>
    <div class="btn" id="btnHome">Home</div>
    <div class="btn" id="btnShowAll">Show all</div>
    <div class="btn" id="btnFit">Fit</div>
    <input id="search" placeholder="Search (any property), press Enter" />
    <div class="muted">Hover = focus • Single click = details • Double click = expand</div>
    <div class="muted" id="stats" style="margin-left:auto;"></div>
  </div>

  <div id="app">
    <div id="cy"></div>
    <div id="side">
      <h3>Details</h3>
      <div id="details" class="muted">Home shows 6 hubs. Double click one hub to open that category.</div>
      <hr />
      <div class="muted">
        Tip: Hover a node to reduce clutter. Relationship names show on focused edges (and when zoomed in).
      </div>
      <hr />
      <div id="debug" class="muted"></div>
    </div>
  </div>

<script>
  // ----------------------------- Config -----------------------------
  const COLORS = {
    Material: "#00E5FF",
    ValueChainStage: "#3DB4FF",
    Partner: "#FF2BD6",
    Deliverable: "#9BFF3A",
    Demonstration: "#FFD34A",
    Innovation: "#FF7A00",
    Phase: "#A3A9FF",
    CircularPath: "#B8BFFF",
    Path: "#B8BFFF",
    Other: "#A3A9FF"
  };

  const HUB_COLORS = {
    Material: "#4CC9FF",
    ValueChainStage: "#3DB4FF",
    Partner: "#FF4DE1",
    Deliverable: "#B4FF4A",
    Demonstration: "#FFE06A",
    Innovation: "#FF9A3C"
  };

  const HUBS = [
    { id: "HUB_MAT", label: "Material", title: "Materials" },
    { id: "HUB_STAGE", label: "ValueChainStage", title: "Value Chain Stages" },
    { id: "HUB_PARTNER", label: "Partner", title: "Partners" },
    { id: "HUB_DELIV", label: "Deliverable", title: "Deliverables" },
    { id: "HUB_DEMO", label: "Demonstration", title: "Demonstrations" },
    { id: "HUB_INNO", label: "Innovation", title: "Innovations" }
  ];

  let cy;

  // ----------------------------- Utils -----------------------------
  function asNiceText(v) {
    if (v == null) return "";
    if (Array.isArray(v)) return v.filter(Boolean).join(" • ");
    if (typeof v === "object") return JSON.stringify(v);
    return String(v);
  }

  // Robust ID extraction for many Neo4j export variants
  function neoId(x) {
    if (x == null) return null;
    if (typeof x === "string" || typeof x === "number") return String(x);

    if (x.elementId != null) return String(x.elementId);

    // Browser exports often use identity:{low,high}
    const ident = x.identity ?? x.id;
    if (ident != null) {
      if (typeof ident === "string" || typeof ident === "number") return String(ident);
      if (typeof ident === "object" && ident.low != null) return String(ident.low);
    }

    // Sometimes data.id exists
    if (x.data && x.data.id != null) return String(x.data.id);

    return null;
  }

  function getNumericIdentity(obj) {
    if (!obj) return null;
    const ident = obj.identity ?? obj.id;
    if (ident == null) return null;
    if (typeof ident === "number" || typeof ident === "string") return String(ident);
    if (typeof ident === "object" && ident.low != null) return String(ident.low);
    return null;
  }

  // Make links clickable in the right panel
  function renderValue(v) {
    if (v == null) return "";
    if (Array.isArray(v)) return v.filter(Boolean).map(renderValue).join(" • ");

    if (typeof v === "string") {
      const s = v.trim();
      const isUrl = /^https?:\/\/|^mailto:/i.test(s);
      const isDoi = /^10\.\d{4,9}\//.test(s);
      if (isUrl) return `<a href="${s}" target="_blank" rel="noopener noreferrer">${s}</a>`;
      if (isDoi) return `<a href="https://doi.org/${s}" target="_blank" rel="noopener noreferrer">${s}</a>`;
      return s;
    }
    if (typeof v === "object") return `<code>${JSON.stringify(v)}</code>`;
    return String(v);
  }

  // ----------------------------- Label + Styles -----------------------------
  function pickNodeLabel(d) {
    const labels = d.labels || [];
    const label = labels[0] || "Other";
    const p = d.properties || {};

    if (label === "Material") return asNiceText(p.material) || asNiceText(p.name) || asNiceText(d.id);
    if (label === "ValueChainStage") {
      const stage = asNiceText(p.name);
      const mat = asNiceText(p.material);
      return (stage && mat) ? `${stage} (${mat})` : (stage || mat || asNiceText(d.id));
    }
    if (label === "Partner") return asNiceText(p.partners) || asNiceText(p.partners_legalname) || asNiceText(d.id);
    if (label === "Deliverable") return asNiceText(p.deliverables_no) || asNiceText(p.deliverables_name) || asNiceText(d.id);
    if (label === "Demonstration") return asNiceText(p.demonstrations) || asNiceText(p.demonstrations_type) || asNiceText(d.id);
    if (label === "Innovation") return asNiceText(p.innovations_name) || asNiceText(p.innovations) || asNiceText(d.id);
    if (label === "Phase") return asNiceText(p.phase_id) || asNiceText(p.phases) || asNiceText(p.name) || asNiceText(d.id);
    if (label === "CircularPath" || label === "Path") return asNiceText(p.name) || asNiceText(p.phase_path) || asNiceText(d.id);

    return asNiceText(p.name) || asNiceText(d.id);
  }

  function sizeForLabel(label) {
    if (label === "Material") return 24;
    if (label === "ValueChainStage") return 23;
    if (label === "Partner") return 24;
    if (label === "Deliverable") return 22;
    if (label === "Demonstration") return 21;
    if (label === "Innovation") return 21;
    if (label === "Phase") return 18;
    if (label === "CircularPath" || label === "Path") return 20;
    return 16;
  }
  function colorForLabel(label) { return COLORS[label] || COLORS.Other; }

  // ----------------------------- Details Panel (clean properties) -----------------------------
  function showDetails(ele) {
    const d = ele.data();
    const head = `
      <div style="font-weight:700; font-size:16px; margin-bottom:6px;">${d.title || d.label || "Node"}</div>
      <div class="muted">Type: <code>${d.label || "Node"}</code></div>
      <hr />
    `;

    if (d.kind === "hub") {
      document.getElementById("details").innerHTML = head + `
        <div class="muted">
          Category hub (visual-only).<br><br>
          <b>Double click</b> to reveal nodes in this category.
        </div>`;
      return;
    }

    const topRows = Object.entries(d)
      .filter(([k]) => !["id","color","title","kind","_placed","size","properties","label","labels"].includes(k))
      .sort((a,b) => a[0].localeCompare(b[0]))
      .map(([k,v]) => `<div class="kv"><div class="k">${k}</div><div class="v">${renderValue(v)}</div></div>`)
      .join("");

    const props = d.properties || {};
    const propRows = Object.entries(props)
      .sort((a,b) => a[0].localeCompare(b[0]))
      .map(([k,v]) => `<div class="kv"><div class="k">${k}</div><div class="v">${renderValue(v)}</div></div>`)
      .join("");

    document.getElementById("details").innerHTML =
      head +
      (topRows || "") +
      (propRows ? `<div class="muted" style="margin-top:10px; font-weight:700;">Properties</div>${propRows}` : `<div class="muted">No properties</div>`);
  }

  // ----------------------------- Hover focus -----------------------------
  function enableHoverFocus() {
    cy.on("mouseover", "node", (evt) => {
      const n = evt.target;
      n.addClass("hi");
      n.connectedEdges().addClass("edgeLabelOn");
    });
    cy.on("mouseout", "node", () => {
      cy.elements().removeClass("hi");
      cy.edges().removeClass("edgeLabelOn");
    });
  }

  // ----------------------------- Hubs -----------------------------
  function hubIdFor(label) {
    const L = (label || "").toLowerCase();
    if (L === "material") return "HUB_MAT";
    if (L === "valuechainstage") return "HUB_STAGE";
    if (L === "partner") return "HUB_PARTNER";
    if (L === "deliverable") return "HUB_DELIV";
    if (L === "demonstration") return "HUB_DEMO";
    if (L === "innovation") return "HUB_INNO";
    return null;
  }

  function homeView(force=true) {
    if (force) {
      cy.nodes('[kind="real"]').addClass("hidden");
      cy.edges().addClass("hidden");
      cy.edges('[kind="hubEdge"]').remove();
    }

    cy.$('node[kind="hub"]').removeClass("hidden");

    const w = cy.width(), h = cy.height();
    const cx = w * 0.47;
    const cyy = h * 0.55;
    const R = Math.min(w,h) * 0.28;

    const hubs = HUBS.map(h => cy.getElementById(h.id));
    hubs.forEach((node, i) => {
      const a = (-Math.PI/2) + (2*Math.PI*i)/hubs.length;
      node.position({ x: cx + R*Math.cos(a), y: cyy + R*Math.sin(a) });
    });

    cy.zoom(1);
    cy.center(cy.$('node[kind="hub"]'));

    document.getElementById("details").innerHTML =
      `<div class="muted">Home loaded: only ${HUBS.length} hubs (clean start). Double click a hub to reveal that category.</div>`;
  }

  function revealCategory(label) {
    const hubId = hubIdFor(label);
    if (!hubId) return;

    cy.nodes('[kind="real"]').addClass("hidden");
    cy.edges().addClass("hidden");
    cy.$('node[kind="hub"]').removeClass("hidden");

    const hub = cy.getElementById(hubId);
    const center = hub.position();

    const group = cy.nodes().filter(n => n.data("kind")==="real" && n.data("label")===label);
    group.removeClass("hidden");

    cy.edges('[kind="hubEdge"]').remove();

    const newEdges = [];
    group.forEach(n => {
      const eid = `HE_${hubId}_${n.id()}`;
      newEdges.push({ group:"edges", data:{ id:eid, source:hubId, target:n.id(), label:"", kind:"hubEdge" } });
    });
    if (newEdges.length) cy.add(newEdges);
    cy.edges('[kind="hubEdge"]').removeClass("hidden");

    const nodes = group.toArray();
    const radius = 260;
    const startAngle = -Math.PI / 2;
    nodes.forEach((n, i) => {
      const a = startAngle + (2*Math.PI*i)/Math.max(nodes.length, 1);
      n.position({ x: center.x + radius*Math.cos(a), y: center.y + radius*Math.sin(a) });
    });

    cy.animate({ center: { eles: hub } }, { duration: 180 });

    document.getElementById("details").innerHTML =
      `<div class="muted"><b>${label}</b> opened. Single click nodes for details. Double click a node to expand neighbors.</div>`;
  }

  // Expand only around clicked node (not global)
  function expandRealNeighbors(node) {
    node.removeClass("hidden");

    const realEdges = node.connectedEdges().filter(e => e.data("kind")!=="hubEdge");
    const neighbors = realEdges.connectedNodes();

    realEdges.removeClass("hidden");
    neighbors.removeClass("hidden");

    const c = node.position();
    const neigh = neighbors.toArray().filter(n => n.id() !== node.id());
    const r = 170;

    neigh.forEach((n, i) => {
      if (!n.data("_placed")) {
        const a = (2*Math.PI*i)/Math.max(neigh.length, 1);
        n.position({ x: c.x + r*Math.cos(a), y: c.y + r*Math.sin(a) });
        n.data("_placed", true);
      }
    });

    cy.animate({ center: { eles: node } }, { duration: 160 });
  }

  // Double click detection
  let lastTapTime = 0;
  let lastTapId = null;
  function handleTap(ele) {
    const now = Date.now();
    const id = ele.id();
    const isDouble = (lastTapId === id && (now - lastTapTime) < 350);
    lastTapTime = now;
    lastTapId = id;

    if (!isDouble) { showDetails(ele); return; }
    const d = ele.data();
    if (d.kind === "hub") revealCategory(d.label);
    else expandRealNeighbors(ele);
  }

  // relationship labels: show on hover-focus + when zoomed in
  const EDGE_LABEL_ZOOM = 1.05;
  function updateEdgeLabelVisibility() {
    const z = cy.zoom();
    if (z >= EDGE_LABEL_ZOOM) cy.edges().addClass("show-edge-labels");
    else cy.edges().removeClass("show-edge-labels");
  }

  // ----------------------------- IMPORTANT: Neo4j JSON parsing -----------------------------
  // This parser handles:
  // A) Neo4j Browser download: [{json:{elements:{nodes,edges}}}]
  // B) Your own: {elements:{nodes,edges}}
  // C) Row-array exports: [{n:{...}, r:{...}, m:{...}}, ...]
  // D) Row-array where relationships don't carry endpoints -> it uses row n/m as fallback
  function rowsNrmToElements(rows) {
    const nodeMap = new Map();   // cytoscapeId -> node
    const idMap = new Map();     // numericId -> cytoscapeId (helps when rel endpoints are numeric)
    const edgeMap = new Map();   // de-dupe

    function addNode(nodeObj) {
      if (!nodeObj) return null;
      const cid = neoId(nodeObj);
      if (!cid) return null;

      if (!nodeMap.has(cid)) {
        const labels = nodeObj.labels || (nodeObj.label ? [nodeObj.label] : []);
        const properties = nodeObj.properties || {};
        nodeMap.set(cid, { data: { id: cid, labels, properties } });

        const numId = getNumericIdentity(nodeObj);
        if (numId) idMap.set(numId, cid);
      }
      return cid;
    }

    function resolveEndpoint(x) {
      if (x == null) return null;
      if (typeof x === "string") return nodeMap.has(x) ? x : (idMap.get(x) || x);
      if (typeof x === "number") return idMap.get(String(x)) || String(x);

      // object form
      const cid = neoId(x);
      if (cid && nodeMap.has(cid)) return cid;

      const num = getNumericIdentity(x);
      if (num && idMap.has(num)) return idMap.get(num);

      if (x.low != null && idMap.has(String(x.low))) return idMap.get(String(x.low));
      return null;
    }

    function addEdge(relObj, fallbackSourceId, fallbackTargetId) {
      if (!relObj) return;

      const rid = neoId(relObj) || `rel_${edgeMap.size}`;
      const type = relObj.type || relObj.label || relObj.relType || "REL";

      const rawS = relObj.startNode ?? relObj.start ?? relObj.source ?? relObj.from ?? relObj.start_id ?? relObj.startId;
      const rawT = relObj.endNode   ?? relObj.end   ?? relObj.target ?? relObj.to   ?? relObj.end_id   ?? relObj.endId;

      const source = resolveEndpoint(rawS) || fallbackSourceId;
      const target = resolveEndpoint(rawT) || fallbackTargetId;

      if (!source || !target) return;

      const key = `${rid}|${source}|${target}|${type}`;
      if (edgeMap.has(key)) return;

      // keep relationship properties if present
      const props = relObj.properties || {};

      edgeMap.set(key, {
        data: {
          id: rid,
          source,
          target,
          type,
          properties: props
        }
      });
    }

    rows.forEach(row => {
      const n = row.n || row.from || row.a || row.sourceNode;
      const m = row.m || row.to   || row.b || row.targetNode;
      const r = row.r || row.rel  || row.e || row.relationship;

      const nId = addNode(n);
      const mId = addNode(m);

      // Add any other node-like objects in the row
      Object.values(row).forEach(v => {
        if (v && typeof v === "object" && (v.labels || v.properties)) addNode(v);
      });

      // Add edge even if r has no endpoints (use fallback n/m)
      addEdge(r, nId, mId);
    });

    return { nodes: [...nodeMap.values()], edges: [...edgeMap.values()] };
  }

  function unwrapAnyNeo4jJson(raw) {
    if (Array.isArray(raw) && raw[0] && raw[0].json && raw[0].json.elements) return raw[0].json.elements;
    if (raw?.elements?.nodes && (raw.elements.edges || raw.elements.relationships)) return raw.elements;

    // Sometimes Neo4j Browser gives {nodes:[...], relationships:[...]} without "elements"
    if (raw?.nodes && (raw?.relationships || raw?.edges)) {
      return { nodes: raw.nodes, edges: raw.relationships || raw.edges };
    }

    // Row arrays [{n,r,m}, ...]
    if (Array.isArray(raw) && raw.length && typeof raw[0] === "object") {
      const el = rowsNrmToElements(raw);
      return { nodes: el.nodes, edges: el.edges };
    }
    return null;
  }

  // ----------------------------- Main -----------------------------
  async function main() {
    const res = await fetch("./graph.json", { cache: "no-store" });
    if (!res.ok) {
      document.getElementById("details").innerHTML =
        `<b>Error</b><br><br>Could not load <code>graph.json</code> (${res.status}). Put it next to <code>index.html</code> in the repo root.`;
      return;
    }

    const raw = await res.json();
    const elements = unwrapAnyNeo4jJson(raw);
    const edgeList = elements?.edges || elements?.relationships;

    if (!elements?.nodes || !edgeList) {
      document.getElementById("details").innerHTML =
        "<b>Error</b><br><br>graph.json format not recognized. It must contain nodes + relationships OR rows like n/r/m.";
      return;
    }

    // Convert nodes
    const realNodes = elements.nodes.map(n => {
      const d = n.data || n; // support {data:{...}} or raw objects
      const labels = d.labels || (d.data?.labels) || [];
      const properties = d.properties || (d.data?.properties) || {};
      const id = d.id || d.elementId || (d.data && d.data.id) || neoId(d);

      const nodeData = {
        id: String(id),
        labels,
        properties
      };

      const label = (labels && labels[0]) || "Other";
      return {
        data: {
          ...nodeData,
          label,
          title: pickNodeLabel(nodeData),
          color: colorForLabel(label),
          size: sizeForLabel(label),
          kind: "real"
        }
      };
    });

    // Build a set of node ids to validate edges
    const nodeIdSet = new Set(realNodes.map(n => n.data.id));

    // Convert edges
    const realEdges = edgeList.map(e => {
      const d = e.data || e;
      const source = d.source || d.startNode || d.start || d.from || d.start_id || d.startId;
      const target = d.target || d.endNode || d.end || d.to || d.end_id || d.endId;

      // normalize endpoints to strings
      const s = (typeof source === "object") ? neoId(source) : String(source ?? "");
      const t = (typeof target === "object") ? neoId(target) : String(target ?? "");

      const id = d.id || d.elementId || neoId(d) || `edge_${Math.random().toString(36).slice(2)}`;
      const type = d.type || d.label || d.relType || "REL";
      const props = d.properties || {};

      return { data: { id: String(id), source: s, target: t, label: type, type, properties: props, kind:"realEdge" } };
    }).filter(e => e.data.source && e.data.target);

    // DEBUG: count edges that point to missing nodes
    const broken = realEdges.filter(e => !nodeIdSet.has(e.data.source) || !nodeIdSet.has(e.data.target));
    const goodEdges = realEdges.filter(e => nodeIdSet.has(e.data.source) && nodeIdSet.has(e.data.target));

    // Put debug info in sidebar
    document.getElementById("debug").innerHTML =
      `<div class="pill">Loaded nodes: <b>${realNodes.length}</b></div>
       <div class="pill" style="margin-left:6px;">Edges in file: <b>${realEdges.length}</b></div>
       <div class="pill" style="margin-left:6px;">Drawable edges: <b>${goodEdges.length}</b></div>
       ${broken.length ? `<div style="margin-top:8px;" class="muted">⚠️ <b>${broken.length}</b> edges reference missing node ids (id mismatch). Export likely mixes numeric ids and elementIds.</div>` : ""}`;

    document.getElementById("stats").innerHTML =
      `Nodes: <b>${realNodes.length}</b> • Edges: <b>${goodEdges.length}</b>`;

    // Hubs
    const hubNodes = HUBS.map(h => ({
      data: { id:h.id, label:h.label, title:h.title, color:HUB_COLORS[h.label] || "#B8BFFF", size:125, kind:"hub" }
    }));

    cy = cytoscape({
      container: document.getElementById("cy"),
      elements: { nodes: [...hubNodes, ...realNodes], edges: goodEdges },
      style: [
        { selector: ".hidden", style: { "display": "none" } },
        { selector: ".dim", style: { "opacity": 0.10 } },
        { selector: ".hi", style: { "opacity": 1, "shadow-blur": 30, "shadow-opacity": 0.7, "shadow-color": "#ffffff" } },

        {
          selector: 'node[kind="real"]',
          style: {
            "background-color":"data(color)",
            "width":"data(size)","height":"data(size)",
            "border-width":2,"border-color":"rgba(255,255,255,0.18)",
            "label":"data(title)","color":"#E9ECFF","font-size":12,
            "text-wrap":"wrap","text-max-width":120,
            "text-outline-width":4,"text-outline-color":"#000",
            "shadow-blur":16,"shadow-color":"data(color)","shadow-opacity":0.30
          }
        },
        {
          selector:'node[kind="hub"]',
          style:{
            "width":125,"height":125,
            "border-width":5,"border-color":"rgba(233,236,255,0.35)",
            "background-color":"data(color)","background-opacity":0.88,
            "label":"data(title)","color":"#FFF","font-size":18,"font-weight":"bold",
            "text-outline-width":5,"text-outline-color":"#000",
            "shadow-blur":30,"shadow-color":"data(color)","shadow-opacity":0.60
          }
        },

        {
          selector:"edge",
          style:{
            "curve-style":"unbundled-bezier",
            "control-point-distances":46,
            "control-point-weights":0.5,
            "line-color":"rgba(200,220,255,0.22)",
            "width":2,
            "target-arrow-shape":"triangle",
            "target-arrow-color":"rgba(200,220,255,0.40)",
            "label":"",
            "font-size":10,
            "color":"rgba(255,255,255,0.90)",
            "text-outline-width":4,
            "text-outline-color":"#000"
          }
        },
        {
          selector: "edge.show-edge-labels",
          style: {
            "label":"data(label)",
            "text-background-opacity":0.70,
            "text-background-color":"rgba(0,0,0,0.75)",
            "text-background-padding":"2px",
            "text-rotation":"autorotate"
          }
        },
        {
          selector:"edge.edgeLabelOn",
          style:{
            "label":"data(label)",
            "text-background-opacity":0.70,
            "text-background-color":"rgba(0,0,0,0.75)",
            "text-background-padding":"2px",
            "text-rotation":"autorotate"
          }
        },
        {
          selector:'edge[kind="hubEdge"]',
          style:{
            "curve-style":"unbundled-bezier",
            "control-point-distances":32,
            "control-point-weights":0.5,
            "line-color":"rgba(233,236,255,0.22)",
            "target-arrow-color":"rgba(233,236,255,0.28)",
            "width":2,
            "label":""
          }
        }
      ],
      wheelSensitivity: 0.15
    });

    cy.minZoom(0.35); cy.maxZoom(2.5);
    enableHoverFocus();
    cy.on("tap","node",(evt)=>handleTap(evt.target));
    cy.on("zoom", updateEdgeLabelVisibility);
    updateEdgeLabelVisibility();

    document.getElementById("btnHome").onclick = () => homeView(true);
    document.getElementById("btnFit").onclick = () => cy.fit(undefined, 30);

    document.getElementById("btnShowAll").onclick = () => {
      cy.nodes().removeClass("hidden");
      cy.edges().removeClass("hidden");
      document.getElementById("details").innerHTML =
        `<div class="muted">All nodes shown. Hover a node to focus and see relationship names.</div>`;
      updateEdgeLabelVisibility();
    };

    document.getElementById("search").addEventListener("keydown",(e)=>{
      if (e.key !== "Enter") return;
      const q = e.target.value.trim().toLowerCase();
      if (!q) return;

      const hit = cy.nodes().filter(n=>{
        const d=n.data();
        if (d.kind!=="real") return false;

        // search in top-level + in properties object
        const vals = Object.values(d).concat(Object.values(d.properties || {}));
        return vals.some(v => asNiceText(v).toLowerCase().includes(q));
      }).first();

      if (hit && hit.length) {
        hit.removeClass("hidden");
        showDetails(hit);
        cy.animate({ center:{ eles: hit } }, { duration: 200 });
      }
    });

    // Start clean
    homeView(true);

    // If there are edges, show a helpful note
    if (goodEdges.length === 0) {
      document.getElementById("details").innerHTML =
        `<b>No relationships drawn</b><br><br>
         This means your <code>graph.json</code> relationships reference node ids that don't exist in the node list (Neo4j id mismatch).<br><br>
         Check the Debug box below (it will say edges reference missing node ids).`;
    }
  }

  main().catch(err => {
    console.error(err);
    document.getElementById("details").innerHTML = "<b>Error</b><br><br>" + String(err);
  });
</script>
</body>
</html>

